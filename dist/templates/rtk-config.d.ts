export declare const RTK_CONFIG_TEMPLATE = "import { createApi, fetchBaseQuery, FetchBaseQueryError } from \"@reduxjs/toolkit/query/react\";\n\n// Utility pour invalider les tags conditionnellement\nexport const invalidateOn = <T>(\n  { success, error }: { success?: T[]; error?: T[] }\n) => {\n  return (result: unknown, _error: unknown, _arg: unknown) => \n    result ? (success ?? []) : (error ?? []);\n};\n\n// Configuration du baseQuery\nconst getBaseQuery = () =>\n  fetchBaseQuery({\n    baseUrl: process.env.NEXT_PUBLIC_API_URL,\n    prepareHeaders: async (headers) => {\n      const token = localStorage.getItem('token') || localStorage.getItem('authToken');\n      \n      if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", \"application/json\");\n      }\n      \n      if (token) {\n        headers.set(\"Authorization\", `Bearer ${token}`);\n      }\n      \n      return headers;\n    },\n  });\n\n// Classe pour g\u00E9rer les erreurs de r\u00E9ponse\nexport class ResponseError<InFields extends string = string> extends Error {\n  private readonly globalError?: string;\n  private readonly fieldsErrors?: Record<InFields, string>;\n\n  constructor(\n    { status, data }: FetchBaseQueryError\n  ) {\n    super();\n    \n    switch (status) {\n      case \"TIMEOUT_ERROR\":\n        this.globalError = \"Request timed out. Please try again.\";\n        break;\n      case \"FETCH_ERROR\":\n        this.globalError = \"Cannot reach out to the server. Please try again.\";\n        break;\n      case \"PARSING_ERROR\":\n        this.globalError = \"Error parsing server response.\";\n        break;\n      default:\n        if (data && typeof data === 'object') {\n          const responseData = data as { message?: string; errors?: Record<InFields, string> };\n          this.globalError = responseData.message || \"Something went wrong. Please try again.\";\n          this.fieldsErrors = responseData.errors;\n        } else {\n          this.globalError = \"Something went wrong. Please try again.\";\n        }\n        break;\n    }\n  }\n\n  export<OutFields extends string = InFields>(\n    fieldsMap?: Partial<Record<InFields, OutFields>>\n  ) {\n    return {\n      message: this.globalError,\n      errors:\n        fieldsMap && this.fieldsErrors\n          ? Object.keys(this.fieldsErrors).reduce(\n              (acc, key) => ({\n                ...acc,\n                [fieldsMap[key as InFields] || key]: this.fieldsErrors![key as InFields],\n              }),\n              {} as Record<string, string>\n            )\n          : this.fieldsErrors || {},\n    };\n  }\n}\n\n// Cl\u00E9 pour extraire le body de la r\u00E9ponse\nexport const RESPONSE_BODY_KEY = \"data\";\n\n// Instance de l'API\nexport const apiInstance = createApi({\n  reducerPath: 'api',\n  tagTypes: [\n    \"Auth\",\n    \"Users\",\n    // Add your tag types here\n  ],\n  baseQuery: getBaseQuery(),\n  endpoints: () => ({}),\n});\n\nexport { getBaseQuery };\n";
//# sourceMappingURL=rtk-config.d.ts.map